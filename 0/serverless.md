## 서버리스
서버리스는 단순히 FaaS(Function-as-a-Service) 만을 의미하지 않는다.  

실제로 서버가 없는 구조는 아니고 서버에서 처리하는 작업을 **_클라우드 기반_** 의 서비스로 처리해 서버 구축 및 관리 비용을 줄이는 구조다.  
개발 기간과 비용을 단축할 수 있을 뿐만 아니라 서버 운영과 유지 보수의 어려움을 크게 줄일 수 있다.  

서버리스는 서비스형 **_서버리스_**(Serviceful Serverless) 와 **_FaaS_** 로 나눌 수 있다.  
2가지 모두 서비스 형태로 무언가를 제공한다는 의미이며 여기서 서비스라는 의미는 소유하지 않고 사용한 만큼만 비용을 지불한다는 의미다.  

### 서비스형 서버리스(Serviceful Serverless)
클라이언트의 사양이 좋아지고 프레임워크가 발전하면서 많은 로직을 **_클라이언트에서 자체적_** 으로 처리하게 되었다.  
자연스럽게 서버의 역할은 줄어들었고 서버에서 처리하는 작업은 단순해졌다.  

서비스형 서버리스는 직접 서버를 구축하고 프로비저닝하고 관리할 필요 없이 서버의 역할을 서비스 형태로 사용하는 걸 의미한다.  
인증의 경우 매번 새로 구축해야 하지만 Auth0 또는 AWS Cognito 와 같은 인증 서비스를 사용하면 대부분의 구현을 **_대체_** 할 수 있다.  

> 단순 컴퓨팅 리소스, 스토리지, 네트워크뿐만 아니라 머신 러닝, 모바일 백엔드, 블록체인, IOT 등  
> 기능을 복잡한 인프라 구성 없이 간편하게 사용할 수 있다.

<br>

### 함수형 서비스(FaaS)
로직이 담긴 함수 구현만 신경 쓰면 된다.  

함수를 실행하기 위해 서버를 올리고 런타임을 구성하고 코드를 배포해 실행해야 하는 일련의 과정을 없애고  
사용자가 원하는 로직을 함수로 작성만 해놓으면(특정 조건) 함수가 실행된다.  
함수가 호출되면 VM(또는 Container) 가 실행되고 해당 런타임 내에 정의해놓은 함수가 실행되고 실행이 종료되면 VM(Container) 는 종료된다.  

함수는 서버가 대기하면서 요청을 처리하는 게 아닌 이벤트(Event Trigger)가 있을 경우에만 실행되는 작은 코드다.  
주요 서비스 사이에서 간단한 작업을 처리하는 용도로 쓰이고 애플리케이션과 결합해 시너지 효과를 낼 수 있다.  

> OnDemand

<br>

### Serverless Application
**서버리스 애플리케이션의 유형**    
- 클라이언트에서 사용자 인터랙션 로직을 대부분 처리
- 자주 사용하는 서버 기능은 서버리스형 서비스로 처리
- 각종 연계를 위해 사용하는 작은 함수(FaaS)  

클라이언트에서 사용자와 상호작용하는 로직 대부분을 처리해 서버의 역할을 줄이고 서버에서 제공하는 기능은 서버리스형 서비스를 적극 활용한다.  
각 서비스 간 로직은 FaaS 이용해 구현한다.  

1. **서버리스 블로그 웹 애플리케이션 아키텍처**    
    - 사용자에게 보여줄 웹 페이지 및 정적 콘텐츠는 S3 에 저장 후 호스팅
    - 사용자 요청은 API Gateway 로 받기
    - 처리할 내용은 Lambda 에 작성
    - 데이터 저장은 DB 서비스(Dynamo) 사용
    - 사용자 인증은 AWS Cognito 사용
    - Route 53 으로 도메인 구입 및 제공  
  

2. **모바일 백엔드**  
    웹 애플리케이션과 동일하지만 몇 가지 추가된 서비스가 있다.
    - DynamoDB 에 저장하는 데이터는 람다를 이용해 검색엔진 서비스인 CloudSearch 에 저장
    - SNS(Simple Notification Service) 를 이용해 사용자에게 푸시 전송  
  

3. **실시간 스트림 데이터 처리**  
    - Kinesis 로 실시간 스트리밍 데이터 수집
    - 람다에서 들어오는 데이터를 처리하고 저장
    - 이벤트 자체를 장기간 보존하기 위해 S3 에 저장
    - 수집한 데이터는 CloudWatch 를 이용해 모니터링

<br>

### Function  
특정 조건 하에 이벤트가 발생하면 VM(또는 Container) 을 띄워 해당 함수를 실행하고 결과를 지정한 대로 처리한다.  
함수가 실행되려면 환경이 필요한데 이를 런타임이라고 한다. 당연한 얘기지만 런타임은 해당 함수를 어떤 언어로 작성하느냐에 따라 다르며 실행에 필요한 환경이 설치되어 있어야 한다.  

<br>

#### 구성 요소
1. **Handler 함수**  
    호출 시 실행되는 함수  
2. **Event 객체**  
    함수가 호출된 **_이벤트 정보_** 를 담고 있는 객체
3. **Context 객체**  1
    해당 함수의 컨텍스트 정보(**_실행 관련 정보_**)를 담고 있는 객체  
  

#### 내부 함수 구조
- **Event Source**  
    함수가 실행될 조건이자 **_이벤트 소스_**(HTTP Request, Message, Cron, S3 Trigger 등)  
- **Function**  
    작업할 내용  
- **Service**  
    작업 결과를 처리(DB 저장, 다른 서비스로 전달, 메시징, 출력 등)
  
#### 내부 실행 환경 내부 구조
- **Compute substrate**      
    함수가 실행될 VM 또는 Container
- **Execution Environment**    
    그 위에 환경 변수 등 실행 환경이 포함
- **Language Runtime**  
    그 위에 언어별 런타임이 올라가며 언어에 따라 성능 차이 발생
- **Your Function**    
    작성된 코드 조각  

  

### FaaS 성능 최적화
항상 실행되고 있는 서버에 비해 확실히 자원과 비용의 소모가 적다. 하지만 서버에 요청이 있을 경우에만 VM 이나 Container 를 띄운다고 하면 성능 이슈가 생긴다.  

#### Cold Start Delay
Lambda 가 실행되면 해당 함수 코드를 찾아 다운로드하고 새로운 실행 환경울 구성하며 이 과정을 차갑게 식은 서버를 실행하는 거에 비유해 콜드 스타트라고 한다.  
함수가 처음 호출되거나 업데이트된 후 실행할 경우 어쩔 수 없이 발생하는 지연(Delay)이다.

#### 함수 영역(Your Function)을 최적화할 수 있는 방법      
1. 콜드 스타트일 경우에만 처음부터 끝까지 실행하고 재사용 시 진입점인 핸들러 함수만 실행
2. 꼭 필요한 라이브러리와 프레임워크만 사용하고 크기가 가벼운 걸 사용 
3. 간결한 코드
4. 모든 로직을 하나의 함수에 담는 거보다 여러 작은 함수로 분리(시간이 올래걸린다면 전체 리소스가 전부 대기해야 함)
5. 핵심 로직에서 핸들러 함수를 분리하면 단위 테스트를 더 많이 생성 가능
6. 람다 환경 변수를 활용해 하드 코딩 제거
7. 재귀 호출 지양

